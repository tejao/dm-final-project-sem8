# -*- coding: utf-8 -*-
"""jupyter dm final project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RjK-Jq2HZGj-wFyvKO7CJ5dHGnGfuK4O
"""

!pip install colorthief

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib
import ipywidgets as widgets
from IPython.display import display
import tqdm as tqdm
from colorthief import ColorThief
from collections import defaultdict

from google.colab import drive
drive.mount('/content/drive')

df = pd.read_csv("/content/drive/MyDrive/Untitled spreadsheet - Data.csv")
df.head()

df.columns = df.columns.str.strip()
print(df.columns)

df['Total'] = df.groupby(['Year', 'To country'])['Points'].transform('sum')

df_pivot = df.pivot_table(index=['Year', 'To country'], columns='From country', values='Points', fill_value=0)
df_pivot.reset_index(inplace=True)

df_pivot.head()

print(df_pivot.columns)

columns_to_convert=['Year','Albania', 'Andorra', 'Armenia', 'Australia',
       'Austria', 'Azerbaijan', 'Belarus', 'Belgium', 'Bosnia & Herzegovina',
       'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'Estonia',
       'F.Y.R. Macedonia', 'Finland', 'France', 'Georgia', 'Germany', 'Greece',
       'Hungary', 'Iceland', 'Ireland', 'Israel', 'Italy', 'Latvia',
       'Lithuania', 'Luxembourg', 'Macedonia', 'Malta', 'Moldova', 'Monaco',
       'Montenegro', 'Morocco', 'Netherlands', 'North Macedonia', 'Norway',
       'Poland', 'Portugal', 'Rest of the World', 'Rest of the world',
       'Romania', 'Russia', 'San Marino', 'Serbia', 'Serbia & Montenegro',
       'Slovakia', 'Slovenia', 'Spain', 'Sweden', 'Switzerland', 'Turkey',
       'Ukraine', 'United Kingdom', 'Yugoslavia']

df_pivot[columns_to_convert] = df_pivot[columns_to_convert].astype(int)

df_pivot.head()

df_pivot.columns

df_pivot.columns.name = None
df_pivot.reset_index(drop=True, inplace=True)
df_pivot.columns

df_pivot['Total'] = df_pivot.iloc[:, 2:].sum(axis=1)

df_pivot['Rank'] = df_pivot.groupby('Year')['Total'].rank(ascending=False, method='min').astype(int)

df_pivot.rename(columns={'To country': 'Country'}, inplace=True)

columns = df_pivot.columns.tolist()

last_columns = columns[-2:]
columns = columns[:-2]
columns.insert(2, last_columns[0])
columns.insert(3, last_columns[1])

df_pivot.head()

df_pivot.tail(5)

votes_melted = df_pivot.melt(id_vars=['Year', 'Country', 'Total', 'Rank'], var_name='Source Country', value_name='points')

votes_melted.head()

graphs_by_year = {}

for year in votes_melted['Year'].unique():
    votes_year = votes_melted[votes_melted['Year'] == year]
    G_year = nx.from_pandas_edgelist(votes_year,
                                     source='Source Country',
                                     target='Country',
                                     edge_attr='points',
                                     create_using=nx.DiGraph())
    graphs_by_year[year] = G_year

def draw_graph(year):
    plt.figure(figsize=(12, 8))
    pos = nx.spring_layout(graphs_by_year[year])
    nx.draw_networkx(graphs_by_year[year], node_color='blue', pos=pos, node_size=100, edge_color='gray', with_labels=True)
    plt.title(f'Graph for Year {year}')
    plt.show()

year_slider = widgets.IntSlider(value=1957, min=1957, max=2023, step=1, description='Year:', style={'description_width': 'initial'},  layout=widgets.Layout(width='80%'), continuous_update=False)
widgets.interact(draw_graph, year=year_slider)

G_2023 = graphs_by_year[2023]

print("Type of Graph:", "Directed" if G_2023.is_directed() else "Undirected")
print("Number of Nodes:", G_2023.number_of_nodes())
print("Number of Edges:", G_2023.number_of_edges())
print("Average in degree:", "{:.4f}".format(sum(dict(G_2023.in_degree()).values()) / G_2023.number_of_nodes()))
print("Average out degree:", "{:.4f}".format(sum(dict(G_2023.out_degree()).values()) / G_2023.number_of_nodes()))

Gsub = G_2023.edge_subgraph([(e[0],e[1]) for e in G_2023.edges(data=True) if e[2]['points']>0])

print("Type of Graph:", "Directed" if Gsub.is_directed() else "Undirected")
print("Number of Nodes:", Gsub.number_of_nodes())
print("Number of Edges:", Gsub.number_of_edges())
print("Average in degree:", "{:.4f}".format(sum(dict(Gsub.in_degree()).values()) / Gsub.number_of_nodes()))
print("Average out degree:", "{:.4f}".format(sum(dict(Gsub.out_degree()).values()) / Gsub.number_of_nodes()))

plt.hist(dict(Gsub.degree()).values())

h = plt.hist(dict(G_2023.in_degree(weight='points')).values())

deg_cen_points = dict(G_2023.in_degree(weight='points'))
{k:deg_cen_points[k] for k in deg_cen_points if deg_cen_points[k]==max(deg_cen_points.values())}

page_rank = dict(nx.pagerank(G_2023,weight='points'))
{k:page_rank[k] for k in page_rank if page_rank[k]==max(page_rank.values())}

between = dict(nx.betweenness_centrality(G_2023,weight='points'))
{k:between[k] for k in between if between[k]==max(between.values())}

countries = pd.read_csv('/content/drive/MyDrive/countries.csv',index_col='Country',encoding="cp1252")
countries.head()

graph_nodes = set(G_2023.nodes())
country_index = set(countries.index)
print(G_2023.nodes)
print(countries.index)

missing_nodes = graph_nodes - country_index

print(missing_nodes)

corrections = {
    'Bosnia & Herzegovina': 'Bosnia and Herzegovina',
    'Rest of the world': 'Rest of the World',
    'Rest of the World': 'Rest of the World',
    'Serbia & Montenegro': 'Serbia',
    'Yugoslavia': 'Montenegro',
    'North Macedonia': 'Macedonia',
    'F.Y.R. Macedonia': 'Macedonia'
}
corrections.pop('Rest of the World', None)
corrections.pop('Rest of the World', None)

nx.relabel_nodes(G_2023, corrections, copy=False)

G_2023.remove_nodes_from(['Rest of the World'])

pos_geo = {node:
           ( max(-10,min(countries.loc[node]['longitude'],55)),
             max(countries.loc[node]['latitude'],25))
               for node in G_2023.nodes()}

pos_geo = {}
for node in G_2023.nodes():
    pos_geo[node] = (
                    max(-10,min(countries.loc[node]['longitude'],55)),
                    max(countries.loc[node]['latitude'],25)
    )

flags = {}
flag_color = {}
for node in tqdm.tqdm_notebook(G_2023.nodes()):
    flags[node] = '/content/drive/MyDrive/flags/'+(countries.loc[node]['cc3']).lower().replace(' ','')+'.png'
    flag_color[node] =  ColorThief(flags[node]).get_color(quality=1)

def RGB(red,green,blue):
    return '#%02x%02x%02x' % (red,green,blue)

plt.figure(figsize=(12, 12))
ax=plt.gca()
fig=plt.gcf()
plt.axis('off')
plt.title('Eurovision 2023 Final Votes', fontsize=24)

pos = nx.layout.fruchterman_reingold_layout(G_2023,k=1,weight = 'points',iterations=1000,scale = 2)

trans = ax.transData.transform
trans2 = fig.transFigure.inverted().transform

tick_params = {'top':'off', 'bottom':'off', 'left':'off', 'right':'off',
              'labelleft':'off', 'labelbottom':'off'}

styles = ['dotted','dashdot','dashed','solid']

for e in G_2023.edges(data=True):
    width = e[2]['points']/48
    style=styles[int(width*3)]
    if width>0.2:
        nx.draw_networkx_edges(G_2023,pos,edgelist=[e],width=width, style=style, edge_color = RGB(*flag_color[e[0]]) )


for node in G_2023.nodes():
    imsize = max((0.4*G_2023.in_degree(node,weight='points')
                  /max(dict(G_2023.in_degree(weight='points')).values()))**2,0.03)  # Adjusting flag size

    flag = matplotlib.image.imread(flags[node])

    (x,y) = pos[node]
    xx,yy = trans((x,y))
    xa,ya = trans2((xx,yy))

    country = plt.axes([xa-imsize/2.0,ya-imsize/2.0, imsize, imsize ])
    country.imshow(flag)
    country.set_aspect('equal')
    country.tick_params(**tick_params)
    country.axis('off')

plt.savefig('eurovision2023_map.png', bbox_inches='tight')
plt.show()

degree_centrality = nx.degree_centrality(G_2023)

for node, centrality in degree_centrality.items():
    print(f"Degree centrality of node {node}: {centrality}")


import networkx as nx


# Assuming G is your graph
degree_centrality = nx.degree_centrality(G)

# Group nodes by their degree centrality
centrality_groups = defaultdict(list)
for node, centrality in degree_centrality.items():
    centrality_groups[centrality].append(node)

# Print groups of nodes with the same degree centrality
for centrality, nodes in centrality_groups.items():
    print(f"Degree Centrality = {centrality}: Nodes = {nodes}")

G_2023.remove_edges_from(nx.selfloop_edges(G_2023))
nx.k_core(G_2023, k=None, core_number=None).nodes

import networkx as nx
import matplotlib.pyplot as plt

# Assuming G is your graph and k is the desired k-core value
k_cores = nx.core_number(G)

# Create a list of nodes for each k-core
k_core_nodes = {}
for node, k_core_value in k_cores.items():
    if k_core_value not in k_core_nodes:
        k_core_nodes[k_core_value] = [node]
    else:
        k_core_nodes[k_core_value].append(node)

# Draw the graph with nodes colored according to their k-core value
pos = nx.spring_layout(G)  # Choose a layout algorithm
plt.figure(figsize=(10, 8))
for k, nodes in k_core_nodes.items():
    nx.draw_networkx_nodes(G, pos, nodelist=nodes, node_size=100, node_color=k, cmap=plt.cm.jet, label=f'k-core {k}')
nx.draw_networkx_edges(G, pos, alpha=0.5)
plt.title('Graph with k-core visualization')
plt.legend()
plt.show()